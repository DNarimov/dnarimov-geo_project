import streamlit as st
from pypdf import PdfReader
import pandas as pd
import math
import re
from openai import OpenAI
from io import BytesIO

client = OpenAI(api_key=st.secrets["openai_api_key"])

astm_standards = {
    "Electrical Resistivity Test (ERT)": "ASTM G57",
    "Seismic Refraction Test (SRT)": "ASTM D5777",
    "Atterberg Limit Test": "ASTM D4318",
    "Sieve Analysis": "ASTM D6913",
    "UCS Test - Soil": "ASTM D2166",
    "UCS Test - Rock": "ASTM D7012",
    "Oedometer Test": "ASTM D2435",
    "Direct Shear Test": "ASTM D3080",
    "Collapse Test": "ASTM D5333",
    "California Bearing Ratio": "ASTM D1883",
    "Proctor Test": "ASTM D698"
}

corrosion_classes = [
    (100, float('inf'), "–ù–∏–∑–∫–æ–µ", "–û—á–µ–Ω—å —Å–ª–∞–±–∞—è –∫–æ—Ä—Ä–æ–∑–∏—è"),
    (50.01, 100, "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (20.01, 50, "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–£–º–µ—Ä–µ–Ω–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (10.01, 20, "–£–º–µ—Ä–µ–Ω–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–í—ã—Å–æ–∫–æ–∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (5.01, 10, "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–æ-–∞–∫—Ç–∏–≤–Ω—ã–π", "–ß—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (0, 5, "–í—ã—Å–æ–∫–æ–∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–ß—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
]

corrosion_colors = {
    "–ù–∏–∑–∫–æ–µ": "#d0f0c0",
    "–û—á–µ–Ω—å —Å–ª–∞–±–∞—è –∫–æ—Ä—Ä–æ–∑–∏—è": "#d0f0c0",
    "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#fef3bd",
    "–£–º–µ—Ä–µ–Ω–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#ffd59e",
    "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–æ-–∞–∫—Ç–∏–≤–Ω—ã–π": "#ffadad",
    "–í—ã—Å–æ–∫–æ–∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#ff6b6b",
    "–ß—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#ff6b6b",
    "Out of range": "#cccccc",
    "Invalid": "#e0e0e0"
}

def classify_corrosion(resistivity_ohm_m):
    try:
        val = float(resistivity_ohm_m)
        for low, high, nace, astm in corrosion_classes:
            if low <= val <= high:
                return nace, astm
        return "Out of range", "Out of range"
    except:
        return "Invalid", "Invalid"

def format_float(val):
    try:
        return f"{round(float(str(val).replace(',', '.')), 2):.2f}"
    except:
        return "-"

def parse_distance_to_meters(raw_value):
    val = raw_value.lower().strip().replace(",", ".")
    if re.search(r"(—Å–º|cm)", val):
        number = re.findall(r"[\d\.]+", val)
        if number:
            return round(float(number[0]) / 100, 4)
    try:
        fval = float(val)
        if fval > 10:
            return round(fval / 100, 4)
        return round(fval, 4)
    except:
        return None

def extract_text_from_pdf(pdf_file):
    reader = PdfReader(pdf_file)
    return "".join([page.extract_text() or "" for page in reader.pages])

def ask_gpt_astm_analysis(test_name, extracted_text, model_name, language_code):
    standard = astm_standards.get(test_name, "—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π ASTM —Å—Ç–∞–Ω–¥–∞—Ä—Ç")
    prompt = f'''
You are a geotechnical assistant.

From the report below for the "{test_name}" test, perform the following:

1. Extract **ALL rows** from any tabular data related to this test, even if they seem repetitive or similar. Do not skip any rows. Your table must contain all ERT measurements as found in the file.

2. Build a table with these columns:
   - ‚Ññ –ø/–ø
   - ‚Ññ –í—ã—Ä–∞–±–æ—Ç–∫–∏
   - –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —ç–ª–µ–∫—Ç—Ä–æ–¥–∞–º–∏, –∞ (–º)
   - –ü–æ–∫–∞–∑–∞–Ω–∏–µ –ø—Ä–∏–±–æ—Ä–∞ R (–û–º)
   - –£–¥–µ–ª—å–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ œÅ = 2œÄRa (–û–º¬∑–º)
   - –ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å –ø–æ NACE
   - –ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ ASTM

3. Use 2 decimal places for all numeric values. If a value is missing or unparseable ‚Äî write "-".

4. After the table, list:
   - Any missing or invalid values (specify row/column).
   - What ASTM-required parameters are missing or incomplete based on {standard}.

Use language: {language_code.upper()}.
Report:
"""{extracted_text}"""
'''
    try:
        response = client.chat.completions.create(
            model=model_name,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2,
            max_tokens=2000
        )
        return response.choices[0].message.content
    except Exception as e:
        return f"‚ùå GPT error: {e}"

def gpt_response_to_table(response):
    lines = [line for line in response.strip().split("\n") if line.strip()]
    table_lines = []
    for line in lines:
        if "|" in line and "‚Ññ" not in line and "..." not in line.lower() and "---" not in line:
            table_lines.append(line)

    data = []
    for line in table_lines:
        parts = [p.strip() for p in line.strip("- ").split("|") if p.strip()]
        if len(parts) < 5:
            continue

        number = parts[0]
        well_no = parts[1]
        a_raw = parts[2]
        r_val = parts[3]
        resistivity_val = parts[4]

        a_meters = parse_distance_to_meters(a_raw)
        a_val = format_float(a_meters) if a_meters is not None else "-"
        try:
            r_float = float(r_val.replace(",", "."))
        except:
            r_float = None
        try:
            rho_float = float(resistivity_val.replace(",", "."))
        except:
            rho_float = None

        if (rho_float is None or rho_float < 20) and r_float and a_meters:
            resistivity_val = format_float(2 * math.pi * r_float * a_meters)
        else:
            resistivity_val = format_float(rho_float)

        nace, astm = classify_corrosion(resistivity_val)

        data.append([
            number,
            well_no,
            a_val,
            format_float(r_val),
            resistivity_val,
            nace,
            astm
        ])

    return pd.DataFrame(data, columns=[
        "‚Ññ –ø/–ø",
        "‚Ññ –í—ã—Ä–∞–±–æ—Ç–∫–∏",
        "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —ç–ª–µ–∫—Ç—Ä–æ–¥–∞–º–∏ –∞, (–º)",
        "–ü–æ–∫–∞–∑–∞–Ω–∏–µ –ø—Ä–∏–±–æ—Ä–∞ R, (–û–º)",
        "–£–¥–µ–ª—å–Ω–æ–µ —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ œÅ=2œÄRa –û–º¬∑–º",
        "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å –ø–æ NACE",
        "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ ASTM"
    ])

def analyze_missing_data(df):
    missing_info = []
    for row_idx, row in df.iterrows():
        for col in df.columns:
            val = str(row[col]).strip().lower()
            if val in ["-", "nan", "", "none"]:
                missing_info.append(f"üö´ –ü—Ä–æ–ø—É—â–µ–Ω–æ –≤ —Å—Ç—Ä–æ–∫–µ {row_idx + 1}, –∫–æ–ª–æ–Ω–∫–∞ '{col}'")
    return missing_info

def style_table(df):
    def nace_color(val):
        return f"background-color: {corrosion_colors.get(val, '#ffffff')}"
    def astm_color(val):
        return f"background-color: {corrosion_colors.get(val, '#ffffff')}"
    def missing_highlight(val):
        if str(val).strip().lower() in ["-", "nan", "", "none"]:
            return "background-color: #f0f0f0; color: #a00"
        return ""
    return df.style \
        .applymap(nace_color, subset=["–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å –ø–æ NACE"]) \
        .applymap(astm_color, subset=["–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ ASTM"]) \
        .applymap(missing_highlight)

# === –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å ===
st.set_page_config(page_title="Geotechnical Test Validator", layout="wide")
st.title("üß™ Geotechnical Test Result Checker")

lang = st.sidebar.selectbox("üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:", ["–†—É—Å—Å–∫–∏–π", "O'zbek", "English"])
lang_codes = {"–†—É—Å—Å–∫–∏–π": "ru", "O'zbek": "uz", "English": "en"}
language_code = lang_codes[lang]

model_choice = st.sidebar.selectbox(
    "ü§ñ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å Juru AI:",
    ["gpt-4-turbo", "gpt-3.5-turbo"],
    index=0
)

st.markdown("üìÑ –ó–∞–≥—Ä—É–∑–∏—Ç–µ PDF –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ç–µ—Å—Ç–∞. GPT –ø—Ä–æ–≤–µ—Ä–∏—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ASTM –∏ –ø–æ–∫–∞–∂–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –∞–Ω–∞–ª–∏–∑–æ–º.")

test_types = list(astm_standards.keys())
tabs = st.tabs(test_types)

for i, test_name in enumerate(test_types):
    with tabs[i]:
        st.header(f"{test_name}")
        uploaded_file = st.file_uploader(f"üìé –ó–∞–≥—Ä—É–∑–∏—Ç–µ PDF –¥–ª—è {test_name}", type="pdf", key=test_name)

        if uploaded_file:
            with st.spinner("üìñ –û–±—Ä–∞–±–æ—Ç–∫–∞ PDF..."):
                text = extract_text_from_pdf(uploaded_file)
                st.success("‚úÖ PDF —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")

            st.subheader("ü§ñ –ê–Ω–∞–ª–∏–∑ JURU AI")
            gpt_response = ask_gpt_astm_analysis(test_name, text, model_choice, language_code)
            df_result = gpt_response_to_table(gpt_response)

            st.dataframe(style_table(df_result), use_container_width=True)

            missing_entries = analyze_missing_data(df_result)
            if missing_entries:
                st.subheader("‚ùó –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:")
                for msg in missing_entries:
                    st.markdown(f"- {msg}")
            else:
                st.success("‚úÖ –í—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç.")

            # –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ GPT (–Ω–∏–∂–µ —Ç–∞–±–ª–∏—Ü—ã)
            lines = gpt_response.strip().splitlines()
            split_index = 0
            for i, line in enumerate(lines):
                if re.match(r"^\s*[-=]{3,}\s*$", line):
                    split_index = i + 1
                    break
            comment_lines = lines[split_index:]
            comment_lines = [
                line for line in comment_lines
                if line.strip() and not re.match(r"^\s*[-=]{3,}$", line) and "..." not in line.lower()
            ]
            if comment_lines:
                st.markdown("### üß† –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –æ—Ç JURU AI:")
                for line in comment_lines:
                    st.markdown(f"- {line}")

            excel_buffer = BytesIO()
            with pd.ExcelWriter(excel_buffer, engine='xlsxwriter') as writer:
                df_result.to_excel(writer, index=False, sheet_name='GPT Analysis')

            st.download_button(
                label="üìä –°–∫–∞—á–∞—Ç—å Excel-–æ—Ç—á—ë—Ç",
                data=excel_buffer,
                file_name=f"{test_name.replace(' ', '_')}_GPT_Report.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
