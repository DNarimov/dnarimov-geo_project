import streamlit as st
from pypdf import PdfReader
import pandas as pd
import math
import re
from openai import OpenAI
from io import BytesIO

client = OpenAI(api_key=st.secrets["openai_api_key"])

# –ü–µ—Ä–µ–≤–æ–¥ –∫–æ–ª–æ–Ω–æ–∫ –ø–æ —è–∑—ã–∫—É
column_translations = {
    "ru": [
        "‚Ññ –ø/–ø",
        "‚Ññ –í—ã—Ä–∞–±–æ—Ç–∫–∏",
        "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —ç–ª–µ–∫—Ç—Ä–æ–¥–∞–º–∏ –∞, (–º)",
        "–ü–æ–∫–∞–∑–∞–Ω–∏–µ –ø—Ä–∏–±–æ—Ä–∞ R, (–û–º)",
        "–£–¥–µ–ª—å–Ω–æ–µ —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ œÅ=2œÄRa –û–º¬∑–º",
        "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å –ø–æ NACE",
        "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ ASTM"
    ],
    "en": [
        "No.",
        "Test Point",
        "Electrode Spacing a, (m)",
        "Instrument Reading R (Ohm)",
        "Resistivity œÅ = 2œÄRa (Ohm¬∑m)",
        "Corrosion Class (NACE)",
        "Corrosion Activity (ASTM)"
    ],
    "uz": [
        "‚Ññ",
        "Ish joyi",
        "Elektrodlar orasidagi masofa a, (m)",
        "Asbob ko'rsatkichi R (Om)",
        "Xususiy qarshilik œÅ = 2œÄRa (Om¬∑m)",
        "Korroziya klassi (NACE)",
        "Korroziya faolligi (ASTM)"
    ]
}

astm_standards = {
    "Electrical Resistivity Test (ERT)": "ASTM G57",
    "Seismic Refraction Test (SRT)": "ASTM D5777",
    "Atterberg Limit Test": "ASTM D4318",
    "Sieve Analysis": "ASTM D6913",
    "UCS Test - Soil": "ASTM D2166",
    "UCS Test - Rock": "ASTM D7012",
    "Oedometer Test": "ASTM D2435",
    "Direct Shear Test": "ASTM D3080",
    "Collapse Test": "ASTM D5333",
    "California Bearing Ratio": "ASTM D1883",
    "Proctor Test": "ASTM D698"
}

corrosion_classes = [
    (100, float('inf'), "–ù–∏–∑–∫–æ–µ", "–û—á–µ–Ω—å —Å–ª–∞–±–∞—è –∫–æ—Ä—Ä–æ–∑–∏—è"),
    (50.01, 100, "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (20.01, 50, "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–£–º–µ—Ä–µ–Ω–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (10.01, 20, "–£–º–µ—Ä–µ–Ω–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–í—ã—Å–æ–∫–æ–∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (5.01, 10, "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–æ-–∞–∫—Ç–∏–≤–Ω—ã–π", "–ß—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
    (0, 5, "–í—ã—Å–æ–∫–æ–∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π", "–ß—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π"),
]

corrosion_colors = {
    "–ù–∏–∑–∫–æ–µ": "#d0f0c0",
    "–û—á–µ–Ω—å —Å–ª–∞–±–∞—è –∫–æ—Ä—Ä–æ–∑–∏—è": "#d0f0c0",
    "–°–ª–∞–±–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#fef3bd",
    "–£–º–µ—Ä–µ–Ω–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#ffd59e",
    "–ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–æ-–∞–∫—Ç–∏–≤–Ω—ã–π": "#ffadad",
    "–í—ã—Å–æ–∫–æ–∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#ff6b6b",
    "–ß—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –∫–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω—ã–π": "#ff6b6b",
    "Out of range": "#cccccc",
    "Invalid": "#e0e0e0"
}

def classify_corrosion(resistivity_ohm_m):
    try:
        val = float(resistivity_ohm_m)
        for low, high, nace, astm in corrosion_classes:
            if low <= val <= high:
                return nace, astm
        return "Out of range", "Out of range"
    except:
        return "Invalid", "Invalid"

def format_float(val):
    try:
        return f"{round(float(str(val).replace(',', '.')), 2):.2f}"
    except:
        return "-"

def parse_distance_to_meters(raw_value):
    val = raw_value.lower().strip().replace(",", ".")
    if re.search(r"(—Å–º|cm)", val):
        number = re.findall(r"[\d\.]+", val)
        if number:
            return round(float(number[0]) / 100, 4)
    try:
        fval = float(val)
        if fval > 10:
            return round(fval / 100, 4)
        return round(fval, 4)
    except:
        return None

def extract_text_from_pdf(pdf_file):
    reader = PdfReader(pdf_file)
    return "".join([page.extract_text() or "" for page in reader.pages])

def ask_gpt_astm_analysis(test_name, extracted_text, model_name, language_code):
    standard = astm_standards.get(test_name, "—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π ASTM —Å—Ç–∞–Ω–¥–∞—Ä—Ç")
    prompt = f'''
You are a geotechnical assistant.

From the report below for the "{test_name}" test, perform the following:

1. Extract ALL rows from any tabular data related to this test. Do not skip repeated or similar values.

2. Build a table with these columns:
   - ‚Ññ –ø/–ø
   - ‚Ññ –í—ã—Ä–∞–±–æ—Ç–∫–∏
   - –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —ç–ª–µ–∫—Ç—Ä–æ–¥–∞–º–∏, –∞ (–º)
   - –ü–æ–∫–∞–∑–∞–Ω–∏–µ –ø—Ä–∏–±–æ—Ä–∞ R (–û–º)
   - –£–¥–µ–ª—å–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ œÅ = 2œÄRa (–û–º¬∑–º)
   - –ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å –ø–æ NACE
   - –ö–æ—Ä—Ä–æ–∑–∏–æ–Ω–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ ASTM

3. Use 2 decimal places for all numeric values. If missing ‚Äî write "-".

4. Then give a plain-language summary:
   - Which values were missing and auto-calculated.
   - Which ASTM-required parameters were not present.
   - Final conclusion: full compliance / partial compliance / major errors.

Use language: {language_code.upper()}.
Report:
"""{extracted_text}"""
'''
    try:
        response = client.chat.completions.create(
            model=model_name,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2,
            max_tokens=2000
        )
        return response.choices[0].message.content
    except Exception as e:
        return f"‚ùå GPT error: {e}"

def gpt_response_to_table(response, language_code):
    lines = [line for line in response.strip().split("\n") if line.strip()]
    table_lines = []
    for line in lines:
        if "|" in line and "‚Ññ" not in line and "---" not in line and "..." not in line:
            table_lines.append(line)

    data = []
    for line in table_lines:
        parts = [p.strip() for p in line.strip("- ").split("|") if p.strip()]
        if len(parts) < 5:
            continue

        number = parts[0]
        well_no = parts[1]
        a_raw = parts[2]
        r_val = parts[3]
        resistivity_val = parts[4]

        a_meters = parse_distance_to_meters(a_raw)
        a_val = format_float(a_meters) if a_meters is not None else "-"
        try:
            r_float = float(r_val.replace(",", "."))
        except:
            r_float = None
        try:
            rho_float = float(resistivity_val.replace(",", "."))
        except:
            rho_float = None

        if (rho_float is None or rho_float < 20) and r_float and a_meters:
            resistivity_val = format_float(2 * math.pi * r_float * a_meters)
        else:
            resistivity_val = format_float(rho_float)

        nace, astm = classify_corrosion(resistivity_val)

        data.append([
            number,
            well_no,
            a_val,
            format_float(r_val),
            resistivity_val,
            nace,
            astm
        ])

    return pd.DataFrame(data, columns=column_translations.get(language_code, column_translations["ru"]))

def style_table(df):
    def nace_color(val):
        return f"background-color: {corrosion_colors.get(val, '#ffffff')}"
    def astm_color(val):
        return f"background-color: {corrosion_colors.get(val, '#ffffff')}"
    def missing_highlight(val):
        if str(val).strip().lower() in ["-", "nan", "", "none"]:
            return "background-color: #f0f0f0; color: #a00"
        return ""
    return df.style \
        .applymap(nace_color, subset=df.columns[-2:-1]) \
        .applymap(astm_color, subset=df.columns[-1:]) \
        .applymap(missing_highlight)

# === –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å ===
st.set_page_config(page_title="Geotechnical Test Validator", layout="wide")
st.title("Geotechnical Test Result Checker")

lang = st.sidebar.selectbox("üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:", ["–†—É—Å—Å–∫–∏–π", "O'zbek", "English"])
lang_codes = {"–†—É—Å—Å–∫–∏–π": "ru", "O'zbek": "uz", "English": "en"}
language_code = lang_codes[lang]

model_choice = st.sidebar.selectbox("–ú–æ–¥–µ–ª—å Juru AI:", ["gpt-4-turbo", "gpt-3.5-turbo"], index=0)

st.markdown("üìÑ –ó–∞–≥—Ä—É–∑–∏—Ç–µ PDF –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ç–µ—Å—Ç–∞. GPT –ø—Ä–æ–≤–µ—Ä–∏—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ASTM –∏ –ø–æ–∫–∞–∂–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –∞–Ω–∞–ª–∏–∑–æ–º.")

for test_name in astm_standards:
    with st.expander(test_name):
        uploaded_file = st.file_uploader(f"–ó–∞–≥—Ä—É–∑–∏—Ç–µ PDF –¥–ª—è {test_name}", type="pdf", key=test_name)

        if uploaded_file:
            with st.spinner("–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö..."):
                text = extract_text_from_pdf(uploaded_file)

            st.subheader("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞:")
            gpt_response = ask_gpt_astm_analysis(test_name, text, model_choice, language_code)
            df = gpt_response_to_table(gpt_response, language_code)
            st.dataframe(style_table(df), use_container_width=True)

            # –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –æ—Ç GPT
            lines = gpt_response.strip().splitlines()
            comment_lines = []
            table_started = False
            for line in lines:
                if "|" in line and "‚Ññ" in line:
                    table_started = True
                    continue
                if table_started and "|" not in line and len(line.strip()) > 3:
                    comment_lines.append(line.strip())

            comment_lines = [
                line for line in comment_lines
                if line and not line.startswith("|") and "===" not in line and "---" not in line
            ]

            if comment_lines:
                st.markdown("### –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –æ—Ç JURU AI:")
                for line in comment_lines:
                    st.markdown(f"- {line}")

                st.markdown("### üìã –ò—Ç–æ–≥ –ø–æ ERT —Å–æ–≥–ª–∞—Å–Ω–æ ASTM:")
                for line in comment_lines:
                    if any(x in line.lower() for x in ["summary", "–∏—Ç–æ–≥", "compliance", "–æ—à–∏–±–∫–∞", "—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ"]):
                        st.markdown(f"> {line}")

            # –°–∫–∞—á–∞—Ç—å Excel
            buffer = BytesIO()
            with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
                df.to_excel(writer, index=False)
            st.download_button("üì• –°–∫–∞—á–∞—Ç—å Excel", data=buffer.getvalue(), file_name="ERT_Report.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
